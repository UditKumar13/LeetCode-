** Striver Sheet **

Day 1 :

1.Set matrix Zeroes :

(first Inner 2d then check the outer 
first row and first col)

2.Pascal Triangle 
(Array ArrayList  : arr[i-1] + arr[i] logic )

3.Next Permutation :

(find i from the increasing subarray from the last , find j from the last ele
where arr[i] < arr[j] , swap arr[i] and arr[j], now reverse arr[i+1] till arr[n-1])

4.Kadane's algo Maximum Subarray :
(Initially sum =0 , max = arr[0] , 
if Sum<0, then make sum = 0 , now from i=1 to n ,sum+= arr[i] then compete the max ,sum )

5.Sort array of 0's 1's 2's :
(i=0 j =0 k =n-1,
while(i<=k) if arr[i] ==1 i++ , arr[i]==0 swap(arr[i],arr[j]) i++,j++
,arr[i]==2 swap(arr[i],arr[k])k-- simple do this )

6.Buy and Sell :
(It uses the beautiful application of kadane's logic )

2.Day 2 :
7.Rotate Image :

(1.Transpose 2. reverse by row)

8.Merge Intervals :

(start and end use and a condition where s <= end then update else add the range)

9.Merge two sorted array :
(tail approach simply better start from the last ele to first)

10.Duplicate ele :
(Use 2 pointers approach , tortoise and hare algo)

11.Missing number : 
(here we use XOR operator approach bcz a^a = 0)

12.Global and local Inversion : 
(This is the question where the smartness comes into the play... :) 
Just find the 1 counter e.g where it can't return false )

13.Search in 2d matrix :
(Start from the top right corner and start traversal according to the 
constraints given ) 

14.Pow(x,n)

(Beware of the condition of the negative n  :
if (n<0) return 1/x * myPow(1/x, -(n+1))) 

15. Majority ele n>2 :
(We have use the Boyre Moore majority algo)

16.Majority ele n>3 :

(We have used the Boyre Moore majority algo for finding the atmost
 2 number if possible) 

17.Unique paths :
(Learned new way of swapping and how not to use 
factorial function instead use mul and div with a for loop)

18.2 Sum problem :
(We have used the hashmap concept , remaning part and all)

19. 4 sum problem :
(O(n3 solution)

2 for loop of i and j , and a 2 pointer approach from j+1 to n-1)

20.Longest consecuitve sequence :
(He have use the hashset and consecutive logic 
set.remove(num)
int val = num 
int sum =1 
while(set.remove(val-1) ) val--
sum += num -val 

val = num 

while(set.remove(val+1)) val++
sum += val - num 

if(sum>max) update max 

21.Longest subarray with 0 sum :

(Logic is to store the prfix sum in hashmap key as sum and val as index 
if you get the same prefix sum, j - i is a subarray with sum = 0  )

22.Count number of subarrays  with the given xor :
(We have use the hashmap + the startegy of counting the 
xor ^ B count and adding it 
)

23.Longest Substring  without repeat :
(Pepcoding way using the hashmap  and i j while loop with ==2 breaks
condition)

Day 5 : 

24.Reverse a LL 

25.Middle of LL 

26.Merge two sorted LL

27.Remove Nth node from back of LL 

28.Add two numbers ** LL 

29.Delete given node from LL


Day 6 : 

30.

